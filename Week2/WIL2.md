****1. HTTP****

- 서버와 클라이언트의 데이터 교환을 **요청**(Request)과 **응답**(Response) 형식으로 정의한 프로토콜

## HTTP의 기본 메커니즘

- HTTP의 기본 메커니즘은 클라이언트가 서버에게 **요청**하면, 서버가 **응답**
- 웹 서버는 HTTP 서버를 *HTTP 서비스 포트*에 대기시킴.
- 이 포트는 일반적으로 TCP/80 또는 TCP/8080.
- 클라이언트가 서비스 포트에 HTTP 요청을 전송하면, 이를 해석하여 적절한 응답을 반환

## **네트워크 포트와 서비스 포트**

### 네트워크 포트

- **네트워크 포트**(Network Port)란 네트워크에서 서버와 클라이언트가 정보를 교환하는 추상화된 장소를 의미

### 서비스 포트

- **서비스 포트**(Service Port)는 네트워크 포트 중에서 특정 서비스가 점유하고 있는 포트

포트로 데이터를 교환하는 방식은 **전송 계층(Transport Layer)**의 프로토콜을 따른다.

# **HTTP 메시지**

- HTTP 메시지는 클라이언트가 전송하는 HTTP 요청, 그리고 서버가 반환하는 HTTP 응답으로 구성
- 기능과 세부 구조에서는 차이가 있지만, 크게 보면 HTTP 헤드와 바디로 구성된다는 공통점

## **HTTP 헤드**

- HTTP 헤드의 각 줄은 CRLF로 구분, 첫 줄은 시작 줄(Start-line), 나머지 줄은 헤더(Header)
- 헤드의 끝은 CRLF 한 줄로 나타냄
- 시작 줄의 역할은 요청과 응답에서 큰 차이가 있음
- 헤더는 필드와 값으로 구성, HTTP 메시지 또는 바디의 속성을 나타냄
- 하나의 HTTP 메시지에는 0개 이상의 헤더가 있을 수 있음

## **HTTP 바디**

- HTTP 바디는 헤드의 끝을 나타내는 CRLF 뒤, 모든 줄을 말함
- 바디에는 클라이언트나 서버에게 전송하려는 데이터가 담김

## ****HTTP 요청****

- 서버에게 특정 동작을 요구하는 메시지
- 서버는 해당 동작이 실현 가능한지, 클라이언트가 그러한 동작을 요청할 권한이 있는지 등을 검토하고, 적절할 때만 이를 처리

### ****시작 줄****

- HTTP 요청의 시작 줄은 메소드(Method), 요청 URI(Request-URI), 그리고 HTTP 버전으로 구성됩니다. 각각은 띄어쓰기로 구분합니다.
    - **메소드**는 URI가 가리키는 리소스를 대상으로, 서버가 수행하길 바라는 동작
    - **요청 URI :** 메소드의 대상을, **HTTP** **버전**은 클라이언트가 사용하는 HTTP 프로토콜의 버전을 나타냄

### ****헤더와 바디****

- 시작 줄을 제외한 헤더와 바디는 HTTP 메시지에서 설명한 것과 동일

## ****HTTP 응답****

- HTTP 요청에 대한 결과를 반환하는 메시지. 요청을 수행했는지, 하지 않았는지, 안 했다면 이유는 무엇인지와 같은 상태 정보(Status), 그리고 클라이언트에게 전송할 리소스가 응답에 포함

### ****시작 줄****

- HTTP 응답의 시작 줄은 HTTP 버전, 상태 코드(Status Code), 그리고 처리 사유(Reason Phrase)로 구성. 각각은 띄어쓰기로 구분
    - **HTTP 버전**은 서버에서 사용하는 HTTP 프로토콜의 버전을 나타냄
    - **상태 코드**는 요청에 대한 처리 결과를 세 자릿수로 나타냄. HTTP 표준인 [RFC 2616](https://www.rfc-editor.org/rfc/rfc2616.html#section-6)은 대략 40여개의 상태 코드를 정의하고 있는데, 각각은 첫 번째 자릿수에 따라 5개의 클래스로 분류
    - **처리 사유**는 상태 코드가 발생한 이유를 짧게 기술한 것

### ****헤더와 바디****

- 시작 줄을 제외한 헤더와 바디는 HTTP 메시지에서 설명한 것과 동일

****2. HTTPS****
 - 기존의 HTTP의 응답과 요청은 평문으로 전달
- **HTTPS(HTTP over Secure socket layer)**는 TLS(Transport Layer Security) 프로토콜을 도입하여 이런 문제점을 보완.
    - TLS는 서버와 클라이언트 사이에 오가는 모든 HTTP 메시지를 암호화. 공격자가 중간에 메시지를 탈취하더라도 이를 해석하는 것은 불가능, 결과적으로 HTTP 통신이 도청과 변조로부터 보호.
 
HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다. 
하지만 HTTPS를 이용하면 암호화/복호화의 과정이 필요하기 때문에 HTTP보다 속도가 느리다. 또한 HTTPS는 인증서를 발급하고 유지하기 위한 추가 비용이 발생한다.
-> 개인 정보와 같은 민감한 데이터를 주고 받아야 한다면 HTTPS를 이용해야 하지만, 노출이 되어도 괜찮은 단순한 정보 조회 등 만을 처리하고 있다면 HTTP를 이용

****3. RESTful한 URI****
이벤트 목록 조회 : event/list/find
이벤트 조회 : event/find
이벤트 등록 : event/register
이벤트 수정 : event/edit
이벤트 삭제 : event/delete
이벤트 상태 변경 : event-state/change
특정 이벤트의 주문 목록 조회 : event/list/find
멤버 목록 조회 : member/list/find
특정 멤버 권한 변경 : member/auth/edit
특정 멤버 정보 조회 : member/info/find
특정 멤버 정보 변경 : member/info/edit
멤버 등록 : member/register
